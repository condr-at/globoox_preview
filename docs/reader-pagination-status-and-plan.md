# Reader: Пагинация, жесты, прогресс и язык

## 1) Что есть сейчас (факт по коду)

| Область | Статус сейчас | Комментарий |
|---|---|---|
| Постраничная вёрстка | Нет | Сейчас длинный scroll по всей главе |
| Перелистывание drag/swipe | Нет | Обработчиков жестов нет |
| Тап по краям экрана | Нет | Tap-зоны не реализованы |
| Прогресс по блоку (`anchorBlock`) | Нет | Сохраняется только глава + % |
| Сохранение прогресса на сервере | Нет | Endpoint отсутствует |
| Смена языка без потери блока-якоря | Нет | Язык меняется, но якорь блока не фиксируется |
| Прогрессивный перевод | Да | `IntersectionObserver` + `POST /translate` |

### Reader UX
- Текущий ридер = вертикальный скролл всей главы, не постраничный режим.
- Навигация между главами кнопками `prev/next` + TOC.
- Жестов `drag/swipe` для перелистывания страниц нет.
- Тап-зон по краям экрана для перелистывания нет.

### Модель данных и рендер
- Контент приходит массивом `ContentBlock[]` (у блока есть `id` и `position`).
- В UI блоки рендерятся подряд как одна длинная колонка.
- Пагинация (разбиение на страницы под viewport) отсутствует.

### Сохранение прогресса
- Прогресс сохраняется только локально в Zustand (`persist` в local storage).
- Формат прогресса: `bookId -> { chapter, progress%, lastRead }`.
- Якорь чтения на уровне блока (`blockId`/`position`) не сохраняется.
- Серверного endpoint для reading position сейчас нет.

### Язык и перевод
- При смене языка вызывается `PATCH /api/books/:id/language` (сохраняется `selected_language` книги).
- Затем контент главы перечитывается для нового языка.
- Привязка к текущему блоку при смене языка не реализована.

### Прогрессивный перевод
- Да, прогрессивный перевод в проекте есть:
- Хук `useViewportTranslation` отслеживает блоки через `IntersectionObserver`.
- Видимые блоки батчами отправляются в `POST /api/chapters/:id/translate`.
- Переведённые блоки мерджатся в `displayBlocks`.
- Важно: параллельно есть `GET /content?lang=XX`; нужно явно зафиксировать бэкенд-контракт, чтобы не было двойной/конфликтной стратегии.

## 2) Gap относительно целевого состояния

### Нужно сделать во фронте
- Постраничную вёрстку главы под текущий viewport (а не scroll-колонку).
- Перелистывание:
- `drag/swipe` влево/вправо (не от самого края, чтобы не конфликтовать с системными gesture).
- `tap` в near-edge зоны для next/prev page.
- Логику текущего места чтения как `anchorBlock`:
- Это верхний блок текущей страницы.
- Сохраняется и восстанавливается как primary source of truth.
- При смене языка:
- Сохраняем тот же `anchorBlock`.
- Перевёрстываем страницы для нового языка от этого же якоря.
- Текущая страница может измениться, это нормальное поведение.

### Нужно сделать в backend
- Endpoint для чтения/записи reading position (минимум block-anchor).
- Желательно возвращать/принимать не только `blockId`, но и `chapterId` + `blockPosition` (для отказоустойчивости, если blockId изменился).

## 3) Что просить у бэкенда (конкретно)

### Минимум для MVP
- `PUT /api/books/:bookId/reading-position`
- Body:
```json
{
  "chapter_id": "ch-...",
  "block_id": "cb-...",
  "block_position": 123,
  "lang": "EN",
  "updated_at_client": "2026-02-17T12:00:00Z"
}
```
- `GET /api/books/:bookId/reading-position`
- Response:
```json
{
  "book_id": "book-...",
  "chapter_id": "ch-...",
  "block_id": "cb-...",
  "block_position": 123,
  "lang": "EN",
  "updated_at": "2026-02-17T12:00:05Z"
}
```

### Важные требования к контракту
- Идемпотентность `PUT`.
- Last-write-wins по `updated_at`.
- Если `block_id` не найден в текущей ревизии главы:
- fallback по `block_position` (ближайший валидный блок).
- Если нет сохранённой позиции: `404` или `null` (оговорить заранее).

### Опционально (не MVP)
- `POST /api/books/:bookId/reading-position/batch` для throttled массовых обновлений.
- Версионирование главы/блоков (`content_version`) для надёжного восстановления после переимпорта.

## 4) Номера страниц: рекомендация для MVP

- Для MVP лучше **не делать абсолютные номера страниц** (`Page 37 of 412`), потому что:
- Количество страниц зависит от языка, шрифта, размера экрана, safe area.
- При прогрессивном/мозаичном переводе нельзя стабильно и дёшево предсчитать весь `total pages`.
- Риск UX-ошибок выше, чем ценность на старте.

Рекомендую в MVP:
- Показывать главу + относительный прогресс:
- `Chapter 3`
- `Block 128 / 642` (или `%` по blocks в главе)
- Номера страниц добавить позже, когда будет:
- либо полный перевод главы,
- либо фоновая предвёрстка всей главы в выбранной конфигурации (lang + font + viewport).

## 5) План приведения к целевому состоянию

### Этап 0: зафиксировать контракты (быстро)
- Утвердить backend endpoint для `reading-position`.
- Утвердить источник истины для перевода:
- либо `GET /content?lang` возвращает уже готовую локаль,
- либо фронт делает lazy translate через `/translate`.
- Запретить двусмысленность в контракте.

### Этап 1: Anchor-first прогресс
- Добавить client-модель:
- `readingPosition[bookId] = { chapterId, blockId, blockPosition, updatedAt }`.
- Обновлять anchor при каждом успешном page turn (throttle/debounce).
- Синкать anchor на backend.
- На входе в ридер: сначала восстановить anchor, потом строить страницу от него.

### Этап 2: Пагинатор
- Реализовать `paginateBlocks(blocks, startAnchor, layoutConfig)`:
- Вход: `blocks`, viewport height/width, typography settings.
- Выход: массив страниц с `topBlockId` + список видимых блоков/фрагментов.
- Пока можно сделать без сложного text-fragment split внутри одного абзаца (если блок не влезает, переносим целиком), потом улучшить.

### Этап 3: Жесты и тап-зоны
- Добавить слой взаимодействия поверх страницы:
- central safe zone для drag/swipe (без крайних системных зон).
- near-edge tap zones для `prev/next`.
- Условия:
- не перехватывать жесты в input/menu overlay,
- не ломать системный back gesture iOS.

### Этап 4: Смена языка без потери места
- Перед переключением: зафиксировать текущий `anchorBlock`.
- После получения/обновления блоков нового языка:
- найти тот же `blockId` (или fallback по `position`),
- перестроить страницы,
- открыть страницу, где этот блок вверху.

### Этап 5: Полировка и наблюдаемость
- Метрики:
- latency page-turn,
- translation queue latency,
- restore success rate по anchor.
- Логи ошибок для кейсов `anchor not found`.

## 6) Риски и решения

- Риск: конфликт двух стратегий перевода (`GET /content?lang` vs viewport translate).
- Решение: единый контракт и feature-flag режима.

- Риск: тяжелая предвёрстка на больших главах.
- Решение: инкрементальная пагинация от anchor (windowed), не считать всю главу сразу.

- Риск: прыжки позиции при асинхронном приходе переводов.
- Решение: фиксировать `anchorBlock` как source of truth и пересобирать страницы детерминированно.

## 7) Проверка готовности (Definition of Done)

- Ридер открывает книгу на сохранённом `anchorBlock`.
- Перелистывание работает drag/tap, без конфликта с edge system gestures.
- При смене языка пользователь остаётся на том же logical месте (`anchorBlock`), даже если номер страницы визуально меняется.
- Позиция сохраняется на backend и восстанавливается на другом устройстве/сессии.
- При частичном переводе ридер остаётся стабильным, без ложных page numbers.
